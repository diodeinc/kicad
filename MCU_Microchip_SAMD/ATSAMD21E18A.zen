"""ATSAMD21E18A - ARM Cortex-M0+ 32-bit MCU, 48MHz, 256KB Flash, 32KB SRAM

The ATSAMD21E18A is a low-power microcontroller based on the ARM Cortex-M0+ 
32-bit RISC core operating at up to 48 MHz. It features 256KB of Flash memory, 
32KB of SRAM, and an extensive range of enhanced I/Os and peripherals. The device 
includes USB 2.0, up to 6 SERCOM interfaces, 5x 16-bit timers, 3x 24-bit timer/counters 
for control applications, 12-bit ADC, 10-bit DAC, and capacitive touch controller.
It operates from 1.62V to 3.63V and includes advanced power-saving modes.

This module includes optional support for:
- External SPI flash memory (W25Q128JV - 16MB) connected via SERCOM0 on PA04-PA07
- Power from USB using AP2112K-3.3 LDO regulator (5V USB to 3.3V VDD)

Author: @anthropic/claude-opus-4
Reviewer: Nasheed Ur Rehman
Datasheet: https://www.microchip.com/en-us/product/ATSAMD21E18
"""

load("@stdlib/interfaces.zen", "Swd", "I2c", "Spi", "Uart", "Usb2", "Power")

# Dependencies
Resistor = Module("@stdlib/generics/Resistor.zen")
Capacitor = Module("@stdlib/generics/Capacitor.zen")
Crystal = Module("@stdlib/generics/Crystal.zen")
Led = Module("@stdlib/generics/Led.zen")
FerriteBead = Module("@stdlib/generics/FerriteBead.zen")
Inductor = Module("@stdlib/generics/Inductor.zen")
TestPoint = Module("@stdlib/generics/TestPoint.zen")
PinHeader = Module("@stdlib/kicad/PinHeader.zen")
AP2112K_3_3 = Module("../Regulator_Linear/AP2112K-3.3.zen")

# Types
ClockSource = enum("Internal", "Crystal", "External")
CrystalFreq = enum("8MHz", "12MHz", "16MHz", "48MHz")
ResetConfiguration = enum("None", "Pullup", "Button")
BootConfiguration = enum("None", "DoubleTap")

# Configuration
add_bulk_caps = config("add_bulk_caps", bool, default = True)
add_decoupling = config("add_decoupling", bool, default = True)
add_analog_filtering = config("add_analog_filtering", bool, default = True)
add_vddcore_cap = config("add_vddcore_cap", bool, default = True)

# Reset configuration
reset_configuration = config("reset_configuration", ResetConfiguration, default = "Button")

# Boot configuration
boot_configuration = config("boot_configuration", BootConfiguration, default = "DoubleTap")

# Clock configuration
clock_source = config("clock_source", ClockSource, default = "Crystal")
if clock_source == ClockSource("Crystal"):
    crystal_freq = config("crystal_freq", CrystalFreq, default = "16MHz")
    crystal_capacitor_value = config("crystal_capacitor_value", str, default = "12pF")
    add_crystal_series_resistor = config("add_crystal_series_resistor", bool, default = True, optional = True)
    if add_crystal_series_resistor:
        crystal_series_resistor = config("crystal_series_resistor", str, default = "1kohm")

add_low_speed_oscillator = config("add_low_speed_oscillator", bool, default = True)

# Interface configuration  
add_swd_header = config("add_swd_header", bool, default = True)
add_usb = config("add_usb", bool, default = True)
if add_usb:
    power_from_usb = config("power_from_usb", bool, default = True)
else:
    power_from_usb = False
add_status_led = config("add_status_led", bool, default = True)

# SPI Flash configuration
add_spi_flash = config("add_spi_flash", bool, default = True, optional = True)

# External IO
VDD = io("VDD", Net, default = Net("VDD", symbol = Symbol("@kicad-symbols/power.kicad_sym:VDD")))
GND = io("GND", Net, default = Net("GND", symbol = Symbol("@kicad-symbols/power.kicad_sym:GND")))

# USB IO (if enabled)
if add_usb:
    usb = io("USB", Usb2)
    VUSB = io("VUSB", Net, default = Net("VUSB", symbol = Symbol("@kicad-symbols/power.kicad_sym:VBUS")))

# SWD IO (if enabled)
if add_swd_header:
    swd = io("SWD", Swd)

# GPIO pins - expose all available pins
PA00 = io("PA00", Net)
PA01 = io("PA01", Net)
PA02 = io("PA02", Net)
PA03 = io("PA03", Net)

# SPI pins - conditionally exposed based on SPI flash configuration
if add_spi_flash:
    _PA04 = Net("PA04_SPI_CS")    # SPI Chip Select
    _PA05 = Net("PA05_SPI_SCK")   # SPI Clock
    _PA06 = Net("PA06_SPI_MISO")  # SPI MISO
    _PA07 = Net("PA07_SPI_MOSI")  # SPI MOSI
else:
    PA04 = io("PA04", Net)
    PA05 = io("PA05", Net)
    PA06 = io("PA06", Net)
    PA07 = io("PA07", Net)
    _PA04 = PA04
    _PA05 = PA05
    _PA06 = PA06
    _PA07 = PA07

PA08 = io("PA08", Net)
PA09 = io("PA09", Net)
PA10 = io("PA10", Net)
PA11 = io("PA11", Net)
PA14 = io("PA14", Net)
PA15 = io("PA15", Net)
PA16 = io("PA16", Net)
PA17 = io("PA17", Net)
PA18 = io("PA18", Net)
PA19 = io("PA19", Net)
PA22 = io("PA22", Net)
PA23 = io("PA23", Net)
PA27 = io("PA27", Net)
PA28 = io("PA28", Net)

# Conditionally expose pins based on configuration
if not add_usb:
    PA24 = io("PA24", Net)
    PA25 = io("PA25", Net)
else:
    PA24 = usb.DM
    PA25 = usb.DP

if not add_swd_header:
    PA30 = io("PA30", Net)
    PA31 = io("PA31", Net)
else:
    PA30 = swd.SWCLK
    PA31 = swd.SWDIO

# Internal nets
_VDDCORE = Net("VDDCORE")
_VDDANA = Net("VDDANA") if add_analog_filtering else VDD
_RESET = Net("RESET")

# Crystal oscillator nets
if clock_source == ClockSource("Crystal"):
    _XIN = PA14
    _XOUT = PA15

# Low speed oscillator nets
if add_low_speed_oscillator:
    _XIN32 = PA00
    _XOUT32 = PA01

# SAM D21 Microchip SMART ARM-based Flash MCU
Component(
    name = "ATSAMD21E18A",
    symbol = Symbol(library = "@kicad-symbols/MCU_Microchip_SAMD.kicad_sym", name = "ATSAMD21E18A-M"),
    footprint = File("@kicad-footprints/Package_DFN_QFN.pretty/QFN-32-1EP_5x5mm_P0.5mm_EP3.6x3.6mm.kicad_mod"),
    pins = {
        "PA00": PA00,
        "PA01": PA01,
        "PA02": PA02,
        "PA03": PA03,
        "PA04": _PA04,
        "PA05": _PA05,
        "PA06": _PA06,
        "PA07": _PA07,
        "PA08": PA08,
        "PA09": PA09,
        "PA10": PA10,
        "PA11": PA11,
        "PA14": PA14,
        "PA15": PA15,
        "PA16": PA16,
        "PA17": PA17,
        "PA18": PA18,
        "PA19": PA19,
        "PA22": PA22,
        "PA23": PA23,
        "PA24": PA24,
        "PA25": PA25,
        "PA27": PA27,
        "PA28": PA28,
        "PA30": PA30,
        "PA31": PA31,
        "~{RESET}": _RESET,
        "VDDCORE": _VDDCORE,
        "VDDIN": VDD,
        "EP": GND,
        "GND": GND,
        "VDDANA": _VDDANA
    },
)

# Bulk capacitors
if add_bulk_caps:
    Capacitor(name = "C_BULK1", value = "10uF", package = "0805", P1 = VDD, P2 = GND)
    Capacitor(name = "C_BULK2", value = "1uF", package = "0603", P1 = VDD, P2 = GND)

# Power supply decoupling
if add_decoupling:
    # VDDIN decoupling (near pin)
    Capacitor(name = "C_VDDIN", value = "100nF", package = "0402", P1 = VDD, P2 = GND)
    
    # Additional VDDIN decoupling
    Capacitor(name = "C_VDDIN2", value = "100nF", package = "0402", P1 = VDD, P2 = GND)

# VDDCORE capacitor - required for internal regulator
if add_vddcore_cap:
    # Must be low ESR ceramic capacitor
    Capacitor(name = "C_VDDCORE", value = "1uF", package = "0603", P1 = _VDDCORE, P2 = GND)

# Analog power filtering
if add_analog_filtering:
    # Ferrite bead for analog supply isolation
    FerriteBead(name = "FB_VDDANA", package = "0603", P1 = VDD, P2 = _VDDANA)
    
    # VDDANA decoupling
    Capacitor(name = "C_VDDANA1", value = "100nF", package = "0402", P1 = _VDDANA, P2 = GND)
    Capacitor(name = "C_VDDANA2", value = "1uF", package = "0603", P1 = _VDDANA, P2 = GND)

# Reset circuit
if reset_configuration == ResetConfiguration("Pullup"):
    # Pull-up resistor only
    Resistor(name = "R_RESET", value = "10kohms", package = "0402", P1 = _RESET, P2 = VDD)
    
elif reset_configuration == ResetConfiguration("Button"):
    # Pull-up resistor and reset button
    Resistor(name = "R_RESET", value = "10kohms", package = "0402", P1 = _RESET, P2 = VDD)
    
    # Reset capacitor for debouncing
    Capacitor(name = "C_RESET", value = "100nF", package = "0402", P1 = _RESET, P2 = GND)
    
    # Reset button
    Component(
        name = "SW_RESET",
        symbol = Symbol(library = "@kicad-symbols/Switch.kicad_sym", name = "SW_Push"),
        footprint = File("@kicad-footprints/Button_Switch_SMD.pretty/SW_SPST_B3U-1000P.kicad_mod"),
        pins = {
            "1": _RESET,
            "2": GND,
        }
    )

# Boot configuration (double-tap reset for bootloader)
if boot_configuration == BootConfiguration("DoubleTap"):
    # Optional: Add test point for bootloader entry
    TestPoint(name = "TP_BOOT", variant = "THTPad_D1.0mm_Drill0.5mm", P1 = _RESET)

# Crystal oscillator circuit
if clock_source == ClockSource("Crystal"):
    # Determine crystal parameters
    if crystal_freq == CrystalFreq("8MHz"):
        freq_value = "8MHz"
    elif crystal_freq == CrystalFreq("12MHz"):
        freq_value = "12MHz"
    elif crystal_freq == CrystalFreq("16MHz"):
        freq_value = "16MHz"
    else:  # 48MHz
        freq_value = "48MHz"
    
    # Determine crystal output connection
    if add_crystal_series_resistor:
        # Internal net for series resistor
        _R_OSC = Net("_R_OSC")
        crystal_out = _R_OSC
    else:
        # Direct connection without series resistor
        crystal_out = _XOUT
    
    # Crystal
    Crystal(
        name = "Y_HSE",
        frequency = freq_value,
        package = "3225_4Pin",
        XIN = _XIN,
        XOUT = crystal_out,
        GND = GND
    )
    
    # Load capacitors
    Capacitor(name = "C_HSE1", value = crystal_capacitor_value, package = "0402", P1 = _XIN, P2 = GND)
    Capacitor(name = "C_HSE2", value = crystal_capacitor_value, package = "0402", P1 = crystal_out, P2 = GND)
    
    # Series resistor for oscillator stability (if enabled)
    if add_crystal_series_resistor:
        Resistor(name = "R_OSC", value = crystal_series_resistor, package = "0402", P1 = _R_OSC, P2 = _XOUT)

# Low Speed Oscillator for RTC
if add_low_speed_oscillator:
    Crystal(
        name = "Y2",
        frequency = "32.768kHz",
        package = "3215_2Pin",
        XIN = _XIN32,
        XOUT = _XOUT32,
        GND = GND,
    )
    
    # Load capacitors for low speed oscillator
    Capacitor(name = "C_LSE1", value = "12pF", package = "0402", P1 = _XIN32, P2 = GND)
    Capacitor(name = "C_LSE2", value = "12pF", package = "0402", P1 = _XOUT32, P2 = GND)

# USB interface
if add_usb:
    # Internal USB data nets
    _USB_DM_INT = Net("USB_DM_INT")
    _USB_DP_INT = Net("USB_DP_INT")
    
    # USB-C Configuration Channel nets
    _USB_CC1 = Net("USB_CC1")
    _USB_CC2 = Net("USB_CC2")
    
    # USB-C connector
    Component(
        name = "J_USB",
        symbol = Symbol(library = "@kicad-symbols/Connector.kicad_sym", name = "USB_C_Receptacle_USB2.0_16P"),
        footprint = File("@kicad-footprints/Connector_USB.pretty/USB_C_Receptacle_HRO_TYPE-C-31-M-12.kicad_mod"),
        pins = {
            "VBUS": VUSB,
            "D-": _USB_DM_INT,
            "D+": _USB_DP_INT,
            "CC1": _USB_CC1,
            "CC2": _USB_CC2,
            "SBU1": Net("USB_SBU1"),
            "SBU2": Net("USB_SBU2"),
            "GND": GND,
            "SHIELD": GND,
        }
    )
    
    # USB-C CC pull-down resistors (5.1k for device)
    Resistor(name = "R_CC1", value = "5.1kohms", package = "0402", P1 = _USB_CC1, P2 = GND)
    Resistor(name = "R_CC2", value = "5.1kohms", package = "0402", P1 = _USB_CC2, P2 = GND)
    
    # Series resistors on USB data lines
    Resistor(name = "R_USB_DM", value = "22ohms", package = "0402", P1 = _USB_DM_INT, P2 = PA24)
    Resistor(name = "R_USB_DP", value = "22ohms", package = "0402", P1 = _USB_DP_INT, P2 = PA25)
        
    # USB ESD Protection
    Component(
        name = "U_USB_ESD",
        symbol = Symbol(library = "@kicad-symbols/Power_Protection.kicad_sym", name = "USBLC6-2SC6"),
        footprint = File("@kicad-footprints/Package_TO_SOT_SMD.pretty/SOT-23-6.kicad_mod"),
        pins = {
            "I/O1": _USB_DM_INT,
            "GND": GND,
            "I/O2": _USB_DP_INT,
            "VBUS": VUSB,
        },
    )
    
    # VBUS decoupling
    Capacitor(name = "C_VBUS", value = "4.7uF", package = "0805", P1 = VUSB, P2 = GND)
    
    # USB Power Regulation
    if power_from_usb:
        # 3.3V LDO regulator from USB 5V to VDD
        AP2112K_3_3(
            name = "U_USB_REG",
            VIN = Power(NET = VUSB),
            VOUT = Power(NET = VDD),
            GND = GND,
            add_input_cap = add_decoupling,
            add_output_cap = add_decoupling,
            enable_control = "AlwaysOn",
        )

# SWD programming header
if add_swd_header:
    PinHeader(
        name = "J_SWD",
        pins = 4,
        rows = 1,
        pitch = "2.54mm",
        orientation = "Horizontal",
        Pin_1 = GND,       # GND
        Pin_2 = swd.SWDIO, # SWDIO
        Pin_3 = swd.SWCLK, # SWCLK
        Pin_4 = VDD,       # VDD
    )

# Status LED
if add_status_led:
    _LED_K = Net("LED_K")
    Led(
        name = "LED_STATUS",
        color = "yellow",
        package = "0603",
        A = PA17,  # Using PA17 for status LED
        K = _LED_K,
    )
    Resistor(name = "R_LED", value = "1kohms", package = "0402", P1 = _LED_K, P2 = GND)

# SPI Flash Memory
if add_spi_flash:
    # W25Q128JV - 128Mbit (16MB) SPI Flash
    _FLASH_WP = Net("FLASH_WP")
    _FLASH_HOLD = Net("FLASH_HOLD")
    
    Component(
        name = "U_FLASH",
        symbol = Symbol(library = "@kicad-symbols/Memory_Flash.kicad_sym", name = "W25Q128JVS"),
        footprint = File("@kicad-footprints/Package_SO.pretty/SOIC-8_5.3x5.3mm_P1.27mm.kicad_mod"),
        pins = {
            "~{CS}": _PA04,      # Chip Select (active low)
            "CLK": _PA05,        # Clock
            "DI/IO_{0}": _PA07,  # Data In / IO0 (MOSI)
            "DO/IO_{1}": _PA06,  # Data Out / IO1 (MISO)
            "~{WP}/IO_{2}": _FLASH_WP,     # Write Protect
            "~{HOLD}/~{RESET}/IO_{3}": _FLASH_HOLD,  # Hold/Reset
            "VCC": VDD,
            "GND": GND,
        }
    )
    
    # Pull-up resistors for WP and HOLD pins (required for SPI mode)
    Resistor(name = "R_FLASH_WP", value = "10kohms", package = "0402", P1 = _FLASH_WP, P2 = VDD)
    Resistor(name = "R_FLASH_HOLD", value = "10kohms", package = "0402", P1 = _FLASH_HOLD, P2 = VDD)
    
    # Decoupling capacitor for flash
    if add_decoupling:
        Capacitor(
            name = "C_FLASH",
            value = "100nF",
            package = "0402",
            P1 = VDD,
            P2 = GND,
        )

# pcb:sch ATSAMD21E18A x=-229.6000 y=1472.2000 rot=0
# pcb:sch C_LSE1.C x=-465.8200 y=1472.2000 rot=90
# pcb:sch C_LSE2.C x=-465.8200 y=1573.8000 rot=90
# pcb:sch C_BULK1.C x=-173.7200 y=1142.0000 rot=0
# pcb:sch C_BULK2.C x=-84.8200 y=1142.0000 rot=0
# pcb:sch C_HSE1.C x=169.1800 y=1764.3000 rot=0
# pcb:sch C_HSE2.C x=372.3800 y=1764.3000 rot=0
# pcb:sch C_RESET.C x=-288.0200 y=2399.3000 rot=0
# pcb:sch C_VBUS.C x=-427.7200 y=1904.0000 rot=0
# pcb:sch C_VDDANA1.C x=156.4800 y=1357.9000 rot=0
# pcb:sch C_VDDANA2.C x=54.8800 y=1357.9000 rot=0
# pcb:sch C_VDDCORE.C x=-275.3200 y=1345.2000 rot=0
# pcb:sch C_VDDIN.C x=-8.6200 y=1142.0000 rot=0
# pcb:sch C_VDDIN2.C x=80.2800 y=1142.0000 rot=0
# pcb:sch FB_VDDANA.FB x=225.3140 y=1307.1000 rot=90
# pcb:sch J_SWD.PH x=87.9000 y=2285.0000 rot=180
# pcb:sch J_USB x=-839.2000 y=1980.2000 rot=0
# pcb:sch LED_STATUS.LED x=278.4000 y=2178.3200 rot=270
# pcb:sch R_CC1.R x=-531.8600 y=2005.6000 rot=270
# pcb:sch R_CC2.R x=-531.8600 y=2031.0000 rot=270
# pcb:sch R_LED.R x=293.6400 y=2259.6000 rot=0
# pcb:sch R_OSC.R x=382.5400 y=1662.7000 rot=180
# pcb:sch R_RESET.R x=-341.3600 y=2297.7000 rot=180
# pcb:sch R_USB_DM.R x=-341.3600 y=2107.2000 rot=270
# pcb:sch R_USB_DP.R x=-341.3600 y=2158.0000 rot=270
# pcb:sch R_USB_PU1.R x=1017.5400 y=2005.6000 rot=270
# pcb:sch R_USB_PU2.R x=-633.4600 y=2412.0000 rot=0
# pcb:sch SW_RESET x=-382.0000 y=2432.3200 rot=90
# pcb:sch TP_BOOT.TP x=-402.3200 y=2345.9600 rot=270
# pcb:sch U_USB_ESD x=-521.7000 y=2107.2000 rot=0
# pcb:sch U_USB_REG x=-521.7000 y=1955.8000 rot=0
# pcb:sch Y_HSE.Y x=253.0000 y=1700.8000 rot=0
# pcb:sch Y2.Y x=-407.4000 y=1535.7000 rot=90
# pcb:sch GND.1 x=-77.2000 y=2488.2000 rot=0
# pcb:sch GND.2 x=278.4000 y=1865.9000 rot=0
# pcb:sch GND.3 x=-750.3000 y=2437.4000 rot=0
# pcb:sch GND.4 x=-280.4000 y=2551.7000 rot=0
# pcb:sch GND.5 x=-483.6000 y=2272.3000 rot=0
# pcb:sch GND.6 x=-509.0000 y=1650.0000 rot=0
# pcb:sch GND.7 x=214.9000 y=2361.2000 rot=0
# pcb:sch GND.8 x=-267.7000 y=1459.5000 rot=0
# pcb:sch GND.9 x=-407.4000 y=2056.4000 rot=270
# pcb:sch GND.10 x=-166.1000 y=1243.6000 rot=0
# pcb:sch GND.11 x=214.9000 y=1459.5000 rot=0
# pcb:sch GND.12 x=761.0000 y=2361.2000 rot=0
# pcb:sch GND.13 x=-763.0000 y=1865.9000 rot=0
# pcb:sch VDD.1 x=-84.8200 y=1307.1000 rot=0
# pcb:sch VDD.2 x=-338.8200 y=2259.6000 rot=0
# pcb:sch VDD.3 x=207.2800 y=2234.2000 rot=0
# pcb:sch VDD.4 x=296.1800 y=1307.1000 rot=0
# pcb:sch VDD.5 x=-161.0200 y=1091.2000 rot=0
# pcb:sch VDD.6 x=766.0800 y=2005.6000 rot=0
# pcb:sch VDD.7 x=-605.5200 y=1675.4000 rot=0
# pcb:sch VUSB.1 x=-478.5200 y=1853.2000 rot=0
# pcb:sch VUSB.2 x=-923.0200 y=1662.7000 rot=0
# pcb:sch U_FLASH x=672.1000 y=2069.1000 rot=0
# pcb:sch C_FLASH.C x=931.1800 y=2158.0000 rot=0
# pcb:sch R_FLASH_WP.R x=509.5400 y=2069.1000 rot=180
# pcb:sch R_FLASH_HOLD.R x=458.7400 y=2069.1000 rot=180
# pcb:sch U_USB_REG.C_IN.C x=-935.7200 y=1738.9000 rot=0
# pcb:sch U_USB_REG.C_OUT.C x=-618.2200 y=1738.9000 rot=0
# pcb:sch U_USB_REG.U1 x=-826.5000 y=1707.1500 rot=0