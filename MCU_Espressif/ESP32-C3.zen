"""ESP32-C3 - Ultra-Low-Power SoC with RISC-V Single-Core CPU, 2.4 GHz Wi-Fi and Bluetooth 5 (LE)

The ESP32-C3 is an ultra-low-power SoC that supports 2.4 GHz Wi-Fi and Bluetooth Low Energy. 
It features a 32-bit RISC-V single-core processor with up to 160 MHz clock speed, 400 KB SRAM, 
384 KB ROM, and rich connectivity including SPI, I2C, UART, I2S, USB Serial/JTAG, and more. 
The chip includes hardware security features and operates from 2.0V to 3.6V with comprehensive 
power-saving modes.

Author: @anthropic/claude-opus-4
Reviewer: Nasheed Ur Rehman
Datasheet: https://www.espressif.com/documentation/esp32-c3_datasheet_en.pdf
"""

load("@stdlib/interfaces.zen", "Spi", "I2c", "Uart", "Usb2", "Jtag")

# Import TLV70033 module from validated parts
TLV70033_SOT23_5 = Module("../Regulator_Linear/TLV70033_SOT23-5.zen")

# Import PinHeader from stdlib
PinHeader = Module("@stdlib/kicad/PinHeader.zen")


# Dependencies
Resistor = Module("@stdlib/generics/Resistor.zen")
Capacitor = Module("@stdlib/generics/Capacitor.zen")
Crystal = Module("@stdlib/generics/Crystal.zen")
FerriteBead = Module("@stdlib/generics/FerriteBead.zen")
TestPoint = Module("@stdlib/generics/TestPoint.zen")
Inductor = Module("@stdlib/generics/Inductor.zen")

# Types
BootMode = enum("SPI", "Download")
VddSpiVoltage = enum("1.8V", "3.3V")
ClockSource = enum("Internal", "Crystal", "External")
CrystalFreq = enum("26MHz", "40MHz")
BootConfiguration = enum("None", "Resistors", "Button")
BootPull = enum("Pullup", "Pulldown")
ResetConfiguration = enum("None", "Pullup", "TestPoint", "Button")

# Configuration
add_bulk_caps = config("add_bulk_caps", bool, default = True)
add_vdda_filtering = config("add_vdda_filtering", bool, default = True)
add_rtc_filtering = config("add_rtc_filtering", bool, default = True)
add_decoupling = config("add_decoupling", bool, default = True)

# Reset configuration
reset_configuration = config("reset_configuration", ResetConfiguration, default = "Button")

# Boot configuration
boot_configuration = config("boot_configuration", BootConfiguration, default = "Button")
if boot_configuration == BootConfiguration("Resistors"):
    gpio9_pull = config("gpio9_pull", BootPull, default = "Pullup")

# USB configuration
add_usb_circuit = config("add_usb_circuit", bool, default = True)
if add_usb_circuit:
    power_from_usb = config("power_from_usb", bool, default = True, optional = True)

# VDD_SPI configuration
add_vdd_spi_circuit = config("add_vdd_spi_circuit", bool, default = True)
if add_vdd_spi_circuit:
    vdd_spi_voltage = config("vdd_spi_voltage", VddSpiVoltage, default = "3.3V")

# SPI Flash configuration
add_spi_flash = config("add_spi_flash", bool, default = True, optional = True)
if add_spi_flash:
    add_flash_pullups = config("add_flash_pullups", bool, default = True, optional = True)

# Antenna configuration
add_antenna = config("add_antenna", bool, default = True)
if add_antenna:
    antenna_c1_value = config("antenna_c1_value", str, default = "1.5pF", optional = True)
    antenna_l1_value = config("antenna_l1_value", str, default = "2.7nH", optional = True)
    antenna_c2_value = config("antenna_c2_value", str, default = "1.5pF", optional = True)
    antenna_series_resistor_value = config("antenna_series_resistor_value", str, default = "0ohms", optional = True)

# JTAG header configuration
add_jtag_header = config("add_jtag_header", bool, default = True)

# Clock configuration
clock_source = config("clock_source", ClockSource, default = "Crystal")
if clock_source == ClockSource("Crystal"):
    crystal_freq = config("crystal_freq", CrystalFreq, default = "40MHz")
    # Note: If using 26MHz crystal, the PLL bootstrap fuses must be configured accordingly
    # during chip programming. The default ESP32-C3 expects 40MHz.
    crystal_capacitor_value = config("crystal_capacitor_value", str, default = "14pF")
    add_crystal_series_resistor = config("add_crystal_series_resistor", bool, default = True, optional = True)
    if add_crystal_series_resistor:
        crystal_series_resistor = config("crystal_series_resistor", str, default = "0ohm")

add_low_speed_oscillator = config("add_low_speed_oscillator", bool, default = True)

# External IO
VDD = io("VDD", Net, default = Net("VDD", symbol = Symbol("@kicad-symbols/power.kicad_sym:VDD")))
GND = io("GND", Net, default = Net("GND", symbol = Symbol("@kicad-symbols/power.kicad_sym:GND")))

# USB IO (if enabled)
if add_usb_circuit:
    usb = io("USB", Usb2, default = Usb2("USB"))
    VUSB = io("VUSB", Net, default = Net("VUSB", symbol = Symbol("@kicad-symbols/power.kicad_sym:VBUS")))

# JTAG IO (if enabled)
if add_jtag_header:
    jtag = io("JTAG", Jtag)

# Internal nets
_VDD3P3 = Net("VDD3P3")  # Filtered 3.3V for ESP32-C3
_VDD3P3_CPU = VDD  # CPU power directly from VDD
_VDDA = Net("VDDA") if add_vdda_filtering else VDD
_VDD3P3_RTC = Net("VDD3P3_RTC") if add_rtc_filtering else VDD
_VDD_SPI = Net("VDD_SPI")
_LNA_IN = Net("LNA_IN")  # Internal net for antenna connection

# CHIP_EN (reset) - conditionally exposed based on reset configuration
if reset_configuration == ResetConfiguration("None") or reset_configuration == ResetConfiguration("Pullup"):
    CHIP_EN = io("CHIP_EN", Net)  # Exposed to user
    _CHIP_EN = CHIP_EN
else:
    _CHIP_EN = Net("CHIP_EN")  # Internal net for reset circuit

# Crystal nets
if clock_source == ClockSource("Crystal"):
    _XTAL_P = Net("XTAL_P")
    _XTAL_N = Net("XTAL_N")
else:
    _XTAL_P = Net("XTAL_P")
    _XTAL_N = Net("XTAL_N")

# RTC oscillator pins
if add_low_speed_oscillator:
    _XTAL_32K_P = Net("XTAL_32K_P")
    _XTAL_32K_N = Net("XTAL_32K_N")
else:
    _XTAL_32K_P = Net("XTAL_32K_P")
    _XTAL_32K_N = Net("XTAL_32K_N")

# Boot strapping pins
# GPIO9 - boot mode selection (conditionally exposed based on boot configuration)
if boot_configuration == BootConfiguration("None"):
    GPIO9 = io("GPIO9", Net)  # Exposed to user
    _GPIO9 = GPIO9
else:
    _GPIO9 = Net("GPIO9")  # Internal net for boot circuit

# GPIO2 - strapping pin
_GPIO2 = Net("GPIO2")

# GPIO8 - strapping pin for ROM message printing
_GPIO8 = Net("GPIO8")

# GPIO3 - used in the reference design for LED indicator
GPIO3 = io("GPIO3", Net)

# GPIO10 - general purpose IO
GPIO10 = io("GPIO10", Net)

# JTAG pins - conditionally connected to interface or internal nets
if add_jtag_header:
    # Connect to JTAG interface
    _MTCK = jtag.TCK
    _MTDO = jtag.TDO
    _MTDI = jtag.TDI
    _MTMS = jtag.TMS
else:
    # Internal nets
    _MTCK = Net("MTCK")
    _MTDO = Net("MTDO")
    _MTDI = Net("MTDI")
    _MTMS = Net("MTMS")

# SPI Flash pins - conditionally exposed based on flash configuration
if add_spi_flash:
    _SPICS0 = Net("SPICS0")
    _SPID = Net("SPID")
    _SPICLK = Net("SPICLK")
    _SPIHD = Net("SPIHD")
    _SPIWP = Net("SPIWP")
    _SPIQ = Net("SPIQ")
else:
    SPICS0 = io("SPICS0", Net)
    SPID = io("SPID", Net)
    SPICLK = io("SPICLK", Net)
    SPIHD = io("SPIHD", Net)
    SPIWP = io("SPIWP", Net)
    SPIQ = io("SPIQ", Net)
    _SPICS0 = SPICS0
    _SPID = SPID
    _SPICLK = SPICLK
    _SPIHD = SPIHD
    _SPIWP = SPIWP
    _SPIQ = SPIQ

# UART pins
U0TXD = io("U0TXD", Net)
U0RXD = io("U0RXD", Net)

# USB pins
if add_usb_circuit:
    _GPIO18 = usb.DM
    _GPIO19 = usb.DP
else:
    GPIO18 = io("GPIO18", Net)
    GPIO19 = io("GPIO19", Net)
    _GPIO18 = GPIO18
    _GPIO19 = GPIO19

# RF Module, ESP32 SoC, RISC-V, WiFi 802.11b/n/g, Bluetooth LE 5, QFN32
Component(
    name = "ESP32-C3",
    symbol = Symbol(library = "@kicad-symbols/MCU_Espressif.kicad_sym", name = "ESP32-C3"),
    footprint = File("@kicad-footprints/Package_DFN_QFN.pretty/QFN-32-1EP_5x5mm_P0.5mm_EP3.7x3.7mm.kicad_mod"),
    pins = {
        "GPIO2": _GPIO2,
        "GPIO3": GPIO3,
        "GPIO8": _GPIO8,
        "GPIO9": _GPIO9,
        "GPIO10": GPIO10,
        "GPIO18": _GPIO18,
        "GPIO19": _GPIO19,
        "U0TXD": U0TXD,
        "U0RXD": U0RXD,
        "XTAL_32K_P": _XTAL_32K_P,
        "XTAL_32K_N": _XTAL_32K_N,
        "XTAL_N": _XTAL_N,
        "XTAL_P": _XTAL_P,
        "VDD3P3": _VDD3P3,
        "VDD3P3_RTC": _VDD3P3_RTC,
        "VDD3P3_CPU": _VDD3P3_CPU,
        "GND": GND,
        "VDD_SPI": _VDD_SPI,
        "VDDA": _VDDA,
        "LNA_IN": _LNA_IN,
        "CHIP_EN": _CHIP_EN,
        "MTMS": _MTMS,
        "MTDI": _MTDI,
        "MTCK": _MTCK,
        "MTDO": _MTDO,
        "SPIHD": _SPIHD,
        "SPIWP": _SPIWP,
        "SPICS0": _SPICS0,
        "SPICLK": _SPICLK,
        "SPID": _SPID,
        "SPIQ": _SPIQ
    },
)

# JTAG Pin Handling - Expose as IOs when no header
if not add_jtag_header:
    # Expose JTAG pins as regular IOs
    MTCK = io("MTCK", Net)
    MTDO = io("MTDO", Net)
    MTDI = io("MTDI", Net)
    MTMS = io("MTMS", Net)
    # Connect exposed IOs to internal nets
    _MTCK = MTCK
    _MTDO = MTDO
    _MTDI = MTDI
    _MTMS = MTMS

# Bulk Capacitors
if add_bulk_caps:
    Capacitor(name = "C_BULK1", value = "10uF", package = "0805", P1 = VDD, P2 = GND)
    Capacitor(name = "C_BULK2", value = "1uF", package = "0603", P1 = VDD, P2 = GND)

# Power Supply Decoupling
if add_decoupling:
    # VDD3P3_CPU decoupling - CPU power (always on VDD)
    Capacitor(name = "C_CPU", value = "100nF", package = "0402", P1 = _VDD3P3_CPU, P2 = GND)

# VDDA filtering/decoupling - independent of main decoupling
if add_vdda_filtering:
    # VDDA has its own filtered supply
    Capacitor(name = "C_VDDA1", value = "100nF", package = "0402", P1 = _VDDA, P2 = GND)
    Capacitor(name = "C_VDDA2", value = "1uF", package = "0402", P1 = _VDDA, P2 = GND)
elif not add_vdda_filtering and add_decoupling:
    # When VDDA filtering is disabled, add decoupling on VDD instead
    Capacitor(name = "C_VDDA_VDD", value = "100nF", package = "0402", P1 = VDD, P2 = GND)

# VDD3P3_RTC filtering/decoupling - independent of main decoupling
if add_rtc_filtering:
    # RTC has its own filtered supply
    Capacitor(name = "C_RTC", value = "100nF", package = "0402", P1 = _VDD3P3_RTC, P2 = GND)
elif not add_rtc_filtering and add_decoupling:
    # When RTC filtering is disabled, add decoupling on VDD instead
    Capacitor(name = "C_RTC_VDD", value = "100nF", package = "0402", P1 = VDD, P2 = GND)

# VDD3P3 Pi-Filter Circuit (VDD input to VDD3P3 output)
# Input capacitors on VDD (before inductor)
Capacitor(name = "C_VDD3P3_IN1", value = "10uF", package = "0603", P1 = VDD, P2 = GND)
Capacitor(name = "C_VDD3P3_IN2", value = "1uF", package = "0402", P1 = VDD, P2 = GND)
Capacitor(name = "C_VDD3P3_IN3", value = "100nF", package = "0402", P1 = VDD, P2 = GND)

# Series inductor
Inductor(name = "L_VDD3P3", value = "2nH", package = "0402", P1 = VDD, P2 = _VDD3P3)

# Output capacitor on VDD3P3 (after inductor)
Capacitor(name = "C_VDD3P3_OUT", value = "100nF", package = "0402", P1 = _VDD3P3, P2 = GND)

# Power connections with ferrite beads for noise isolation
if add_vdda_filtering:
    FerriteBead(name = "FB_VDDA", package = "0603", P1 = VDD, P2 = _VDDA)
if add_rtc_filtering:
    FerriteBead(name = "FB_VDD3P3_RTC", package = "0603", P1 = VDD, P2 = _VDD3P3_RTC)

# Crystal Oscillator
if clock_source == ClockSource("Crystal"):
    # Crystal frequency selection
    if crystal_freq == CrystalFreq("26MHz"):
        freq_value = "26MHz"
    else:  # 40MHz
        freq_value = "40MHz"
    
    # Determine crystal output connection
    if add_crystal_series_resistor:
        # Internal net for series resistor
        _R_OSC = Net("_R_OSC")
        crystal_out = _R_OSC
    else:
        # Direct connection without series resistor
        crystal_out = _XTAL_N
    
    # Crystal with 3225_4Pin package
    Crystal(
        name = "Y1",
        frequency = freq_value,
        package = "3225_4Pin",
        XIN = _XTAL_P,
        XOUT = crystal_out,
        GND = GND
    )
    
    # Load capacitors
    Capacitor(name = "C_XTAL1", value = crystal_capacitor_value, package = "0402", P1 = _XTAL_P, P2 = GND)
    Capacitor(name = "C_XTAL2", value = crystal_capacitor_value, package = "0402", P1 = crystal_out, P2 = GND)
    
    # Series resistor for oscillator stability (if enabled)
    if add_crystal_series_resistor:
        Resistor(name = "R_OSC", value = crystal_series_resistor, package = "0402", P1 = _R_OSC, P2 = _XTAL_N)

# Low Speed Oscillator for RTC
if add_low_speed_oscillator:
    Crystal(
        name = "Y2",
        frequency = "32.768kHz",
        package = "3215_2Pin",
        XIN = _XTAL_32K_P,
        XOUT = _XTAL_32K_N,
        GND = GND,
    )
    Capacitor(name = "C_OSC3", value = "12pF", package = "0402", P1 = _XTAL_32K_P, P2 = GND)
    Capacitor(name = "C_OSC4", value = "12pF", package = "0402", P1 = _XTAL_32K_N, P2 = GND)

# Reset Circuit
if reset_configuration == ResetConfiguration("Pullup"):
    # Pull-up resistor only
    Resistor(name = "R_PU", value = "10kohms", package = "0402", P1 = _CHIP_EN, P2 = VDD)
    
elif reset_configuration == ResetConfiguration("TestPoint"):
    # Pull-up resistor, capacitor, and test point
    Resistor(name = "R_PU", value = "10kohms", package = "0402", P1 = _CHIP_EN, P2 = VDD)
    Capacitor(name = "C_PU", value = "1uF", package = "0402", P1 = _CHIP_EN, P2 = GND)
    TestPoint(name = "TP_RESET", variant = "THTPad_D1.5mm_Drill0.7mm", P1 = _CHIP_EN)

elif reset_configuration == ResetConfiguration("Button"):
    # Pull-up resistor, capacitor, and reset button
    Resistor(name = "R_PU", value = "10kohms", package = "0402", P1 = _CHIP_EN, P2 = VDD)
    
    # Reset capacitor
    Capacitor(name = "C_PU", value = "1uF", package = "0402", P1 = _CHIP_EN, P2 = GND)
    
    # Reset button
    Component(
        name = "SW_RESET",
        symbol = Symbol(library = "@kicad-symbols/Switch.kicad_sym", name = "SW_Push"),
        footprint = File("@kicad-footprints/Button_Switch_SMD.pretty/SW_SPST_B3U-1000P.kicad_mod"),
        pins = {
            "1": _CHIP_EN,
            "2": GND,
        }
    )

# Boot Configuration Circuit
if boot_configuration == BootConfiguration("None"):
    # No boot configuration - GPIO9 pin exposed to user
    pass

elif boot_configuration == BootConfiguration("Resistors"):
    # GPIO9 - Boot mode selection (strapping pin)
    if gpio9_pull == BootPull("Pullup"):
        # Pull-up for SPI boot mode
        Resistor(name = "R_GPIO9", value = "10kohms", package = "0402", P1 = _GPIO9, P2 = VDD)
    else:  # Pulldown
        # Pull-down for download mode
        Resistor(name = "R_GPIO9", value = "10kohms", package = "0402", P1 = _GPIO9, P2 = GND)
    
    # GPIO2 - strapping pin (recommended pull-up)
    Resistor(name = "R_GPIO2", value = "10kohms", package = "0402", P1 = _GPIO2, P2 = VDD)
    
    # GPIO8 - ROM message printing control (strapping pin)
    # Default floating (no pull)

elif boot_configuration == BootConfiguration("Button"):
    # GPIO9 - Boot mode selection (strapping pin)
    # Default pull-up for SPI boot mode
    Resistor(name = "R_GPIO9", value = "10kohms", package = "0402", P1 = _GPIO9, P2 = VDD)
    
    # Boot button to pull GPIO9 low for download mode
    Component(
        name = "SW_BOOT",
        symbol = Symbol(library = "@kicad-symbols/Switch.kicad_sym", name = "SW_Push"),
        footprint = File("@kicad-footprints/Button_Switch_SMD.pretty/SW_SPST_B3U-1000P.kicad_mod"),
        pins = {
            "1": GND,
            "2": _GPIO9,
        }
    )
    
    # GPIO2 - strapping pin (recommended pull-up)
    Resistor(name = "R_GPIO2", value = "10kohms", package = "0402", P1 = _GPIO2, P2 = VDD)
    
    # GPIO8 - ROM message printing control (strapping pin)
    # Default floating (no pull)

# VDD_SPI Configuration
# ESP32-C3 doesn't have GPIO45 for VDD_SPI voltage selection like ESP32-S3
# VDD_SPI is always connected to VDD (3.3V) on ESP32-C3

# VDD_SPI decoupling
if add_vdd_spi_circuit:
    Capacitor(name = "C_VDD_SPI", value = "100nF", package = "0402", P1 = _VDD_SPI, P2 = GND)

# USB Circuit
if add_usb_circuit:
    # Internal USB data nets (before series resistors)
    _USB_DM_INT = Net("USB_DM_INT")
    _USB_DP_INT = Net("USB_DP_INT")
    
    # USB-C Configuration Channel nets
    _USB_CC1 = Net("USB_CC1")
    _USB_CC2 = Net("USB_CC2")
    
    # USB-C connector (USB 2.0 only)
    Component(
        name = "J_USB",
        symbol = Symbol(library = "@kicad-symbols/Connector.kicad_sym", name = "USB_C_Receptacle_USB2.0_16P"),
        footprint = File("@kicad-footprints/Connector_USB.pretty/USB_C_Receptacle_HRO_TYPE-C-31-M-12.kicad_mod"),
        pins = {
            "VBUS": VUSB,           # VBUS
            "D-": _USB_DM_INT,      # D- (before series resistor)
            "D+": _USB_DP_INT,      # D+ (before series resistor)
            "CC1": _USB_CC1,        # Configuration Channel 1
            "CC2": _USB_CC2,        # Configuration Channel 2
            "SBU1": Net("USB_SBU1"), # Sideband Use 1 (not connected)
            "SBU2": Net("USB_SBU2"), # Sideband Use 2 (not connected)
            "GND": GND,             # GND
            "SHIELD": GND,          # Shield
        }
    )
    
    # USB-C CC (Configuration Channel) pull-down resistors (5.1k for device/sink)
    Resistor(name = "R_USB_CC1", value = "5.1kohms", package = "0402", P1 = _USB_CC1, P2 = GND)
    Resistor(name = "R_USB_CC2", value = "5.1kohms", package = "0402", P1 = _USB_CC2, P2 = GND)
    
    # Series resistors on USB data lines (22 ohms for impedance matching)
    Resistor(name = "R_USB_DM", value = "22ohms", package = "0402", P1 = _USB_DM_INT, P2 = _GPIO18)
    Resistor(name = "R_USB_DP", value = "22ohms", package = "0402", P1 = _USB_DP_INT, P2 = _GPIO19)
    
    # USB ESD Protection
    Component(
        name = "U_USB_ESD",
        symbol = Symbol(library = "@kicad-symbols/Power_Protection.kicad_sym", name = "USBLC6-2SC6"),
        footprint = File("@kicad-footprints/Package_TO_SOT_SMD.pretty/SOT-23-6.kicad_mod"),
        pins = {
            "I/O1": _USB_DM_INT,
            "GND": GND,
            "I/O2": _USB_DP_INT,
            "VBUS": VUSB,
        },
    )
    
    # VBUS decoupling
    Capacitor(name = "C_VBUS", value = "4.7uF", package = "0805", P1 = VUSB, P2 = GND)

    # USB Power Regulation (optional)
    if power_from_usb:        
        # 3.3V LDO regulator from USB 5V to VDD
        TLV70033_SOT23_5(
            name = "U_USB_REG",
            VIN = VUSB,
            VOUT = VDD,
            GND = GND,
            add_input_cap = True,
            add_output_cap = True,
            enable_control = False,
            add_enable_pullup = False,
        )

# SPI Flash Memory
if add_spi_flash:
    # W25Q32JV - 32Mbit (4MB) SPI Flash for ESP32-C3
    Component(
        name = "U_FLASH",
        symbol = Symbol(library = "@kicad-symbols/Memory_Flash.kicad_sym", name = "W25Q32JVSS"),
        footprint = File("@kicad-footprints/Package_SO.pretty/SOIC-8_5.3x5.3mm_P1.27mm.kicad_mod"),
        pins = {
            "~{CS}": _SPICS0,           # Chip Select (active low)
            "CLK": _SPICLK,             # Clock
            "DI/IO_{0}": _SPID,         # Data In / IO0 (MOSI)
            "DO/IO_{1}": _SPIQ,         # Data Out / IO1 (MISO)
            "~{WP}/IO_{2}": _SPIWP,     # Write Protect / IO2
            "~{HOLD}/~{RESET}/IO_{3}": _SPIHD,  # Hold/Reset / IO3
            "VCC": _VDD_SPI,            # Power from VDD_SPI
            "GND": GND,
        }
    )
    
    # Pull-up resistors for WP and HOLD pins (required for normal SPI operation)
    if add_flash_pullups:
        Resistor(name = "R_FLASH_WP", value = "10kohms", package = "0402", P1 = _SPIWP, P2 = _VDD_SPI)
        Resistor(name = "R_FLASH_HD", value = "10kohms", package = "0402", P1 = _SPIHD, P2 = _VDD_SPI)
    
    # Decoupling capacitor for flash
    Capacitor(name = "C_FLASH", value = "100nF", package = "0402", P1 = _VDD_SPI, P2 = GND)

# Antenna Circuit
if add_antenna:
    # Internal nets for antenna connection
    _ANT_PORT1 = _LNA_IN  # Port 1 - near the chip
    _ANT_MATCH = Net("ANT_MATCH")  # Junction between L1 and capacitors
    _ANT_PORT2 = Net("ANT_PORT2")  # Port 2 - near the antenna
    _ANT_FEED = Net("ANT_FEED")  # Connection to antenna after series resistor
    
    # Pi-network matching circuit
    # Port 1 side - Shunt capacitor C1
    Capacitor(name = "C_ANT_PORT1", value = antenna_c1_value, package = "0402", P1 = _ANT_PORT1, P2 = GND)
    
    # Series inductor L1
    Inductor(name = "L_ANT_MATCH", value = antenna_l1_value, package = "0402", P1 = _ANT_PORT1, P2 = _ANT_MATCH)
    
    # Port 2 side - Shunt capacitor C2
    Capacitor(name = "C_ANT_PORT2", value = antenna_c2_value, package = "0402", P1 = _ANT_MATCH, P2 = GND)
    
    # Connection from matching network to antenna
    _ANT_PORT2 = _ANT_MATCH
    
    # Series resistor to antenna (0ohms default for tuning/debugging)
    Resistor(name = "R_ANT", value = antenna_series_resistor_value, package = "0402", P1 = _ANT_PORT2, P2 = _ANT_FEED)
    
    # Antenna component (2-pin chip antenna)
    Component(
        name = "ANT1",
        symbol = Symbol(library = "@kicad-symbols/Device.kicad_sym", name = "Antenna_Chip"),
        footprint = File("@kicad-footprints/RF_Antenna.pretty/Johanson_2450AT18x100.kicad_mod"),
        pins = {
            "FEED": _ANT_FEED,
            "PCB_Trace": GND
        }
    )

# JTAG Header
if add_jtag_header:
    PinHeader(
        name = "J_JTAG",
        pins = 6,
        rows = 1,
        pitch = "2.54mm",
        orientation = "Horizontal",
        Pin_1 = VDD,       # VDD
        Pin_2 = jtag.TMS,  # TMS
        Pin_3 = jtag.TCK,  # TCK
        Pin_4 = jtag.TDO,  # TDO
        Pin_5 = jtag.TDI,  # TDI
        Pin_6 = GND,       # GND
    )

# pcb:sch C_BULK1.C x=689.8800 y=1027.7000 rot=0
# pcb:sch C_BULK2.C x=778.7800 y=1027.7000 rot=0
# pcb:sch C_CPU.C x=1362.9800 y=1027.7000 rot=0
# pcb:sch C_PU.C x=1388.3800 y=2005.6000 rot=0
# pcb:sch C_RTC.C x=893.0800 y=1027.7000 rot=0
# pcb:sch C_VDD1.C x=753.3800 y=837.2000 rot=0
# pcb:sch C_VDD2.C x=854.9800 y=849.9000 rot=0
# pcb:sch C_VDDA1.C x=1235.9800 y=1027.7000 rot=0
# pcb:sch C_VDDA2.C x=1147.0800 y=1027.7000 rot=0
# pcb:sch C_VDD_SPI.C x=1832.8800 y=1535.7000 rot=0
# pcb:sch C_XTAL1.C x=473.9800 y=1878.6000 rot=0
# pcb:sch C_XTAL2.C x=677.1800 y=1878.6000 rot=0
# pcb:sch ESP32-C3 x=786.4000 y=1256.3000 rot=0
# pcb:sch FB_VDD3P3_CPU.FB x=1101.6140 y=608.6000 rot=90
# pcb:sch FB_VDD3P3_RTC.FB x=834.9140 y=976.9000 rot=270
# pcb:sch FB_VDDA.FB x=1292.1140 y=976.9000 rot=90
# pcb:sch R_GPIO9.R x=484.1400 y=1269.0000 rot=180
# pcb:sch R_GPIO2.R x=1322.3400 y=1865.9000 rot=180
# pcb:sch R_GPIO8.R x=496.8400 y=1345.2000 rot=0
# pcb:sch R_PU.R x=1398.5400 y=1865.9000 rot=180
# pcb:sch R_USB_DM.R x=192.0400 y=1738.9000 rot=270
# pcb:sch R_USB_DP.R x=192.0400 y=1815.1000 rot=270
# pcb:sch R_VDD_SPI.R x=407.9400 y=926.1000 rot=0
# pcb:sch SW_BOOT x=443.5000 y=1416.3200 rot=270
# pcb:sch SW_RESET x=1446.8000 y=2000.5200 rot=90
# pcb:sch Y1.Y x=557.8000 y=1815.1000 rot=0
# pcb:sch GND.1 x=583.2000 y=1980.2000 rot=0
# pcb:sch GND.2 x=1002.3000 y=1789.7000 rot=0
# pcb:sch GND.3 x=481.6000 y=1510.3000 rot=0
# pcb:sch VDD.1 x=1007.3800 y=1205.5000 rot=0
# pcb:sch VDD.2 x=1401.0800 y=1713.5000 rot=0
# pcb:sch VDD.3 x=702.5800 y=976.9000 rot=0
# pcb:sch VDD.4 x=486.6800 y=1180.1000 rot=0
# pcb:sch VDD.5 x=346.9800 y=1408.7000 rot=0
# pcb:sch VDD.6 x=1604.2800 y=1865.9000 rot=0

# pcb:sch C_OSC3.C x=562.8800 y=1510.3000 rot=90
# pcb:sch C_OSC4.C x=562.8800 y=1611.9000 rot=90
# pcb:sch R_OSC.R x=687.3400 y=1777.0000 rot=180
# pcb:sch Y2.Y x=595.9000 y=1573.8000 rot=90
# pcb:sch GND.4 x=507.0000 y=1599.2000 rot=90
# pcb:sch GND.6 x=-191.5000 y=2056.4000 rot=0
# pcb:sch GND.7 x=227.6000 y=1573.8000 rot=0
# pcb:sch GND.8 x=62.5000 y=1916.7000 rot=0

# pcb:sch C_VBUS.C x=4.0800 y=1459.5000 rot=0
# pcb:sch J_USB x=-280.4000 y=1624.6000 rot=0
# pcb:sch R_USB_CC1.R x=293.6400 y=1637.3000 rot=270
# pcb:sch R_USB_CC2.R x=293.6400 y=1700.8000 rot=270
# pcb:sch U_USB_ESD x=24.4000 y=1751.6000 rot=0
# pcb:sch U_USB_REG.C_IN.C x=92.9800 y=1459.5000 rot=0
# pcb:sch U_USB_REG.C_OUT.C x=334.2800 y=1459.5000 rot=0
# pcb:sch U_USB_REG.TLV70033_SOT23-5 x=164.1000 y=1427.7500 rot=0
# pcb:sch GND.9 x=341.9000 y=1777.0000 rot=0
# pcb:sch GND.11 x=1675.4000 y=1777.0000 rot=0
# pcb:sch GND.12 x=697.5000 y=1129.3000 rot=0
# pcb:sch GND.13 x=1650.0000 y=1332.5000 rot=0
# pcb:sch GND.14 x=1370.6000 y=1129.3000 rot=0



# pcb:sch C11.C x=880.3800 y=1205.5000 rot=0
# pcb:sch C15.C x=664.4800 y=1205.5000 rot=0
# pcb:sch C16.C x=740.6800 y=1205.5000 rot=0
# pcb:sch FB_VDD.FB x=936.5140 y=1167.4000 rot=270
# pcb:sch IND2.L x=821.3381 y=1154.7000 rot=270
# pcb:sch 3V3.1 x=651.7800 y=1142.0000 rot=0
# pcb:sch VDD.7 x=1375.6800 y=976.9000 rot=0
# pcb:sch GND.16 x=1396.0000 y=2119.9000 rot=0
# pcb:sch C_FLASH.C x=1934.4800 y=1535.7000 rot=0
# pcb:sch R_FLASH_HD.R x=1423.9400 y=1484.9000 rot=180
# pcb:sch R_FLASH_WP.R x=1487.4400 y=1510.3000 rot=180
# pcb:sch U_FLASH x=1586.5000 y=1484.9000 rot=0


# pcb:sch C_VDD3V3_IN1.C x=651.7800 y=1218.2000 rot=0
# pcb:sch C_VDD3V3_IN2.C x=727.9800 y=1218.2000 rot=0
# pcb:sch C_VDD3V3_OUT.C x=918.4800 y=1218.2000 rot=0
# pcb:sch L_VDD3V3.L x=872.1381 y=1167.4000 rot=270
# pcb:sch C_VDD3V3_IN3.C x=804.1800 y=1218.2000 rot=0
# pcb:sch C_VDDA_VDD.C x=1261.3800 y=1129.3000 rot=0
# pcb:sch C_RTC_VDD.C x=867.6800 y=1027.7000 rot=0


# pcb:sch GND.15 x=1599.2000 y=2043.7000 rot=0
# pcb:sch GND.17 x=1332.5000 y=1434.1000 rot=0
# pcb:sch GND.18 x=608.6000 y=1332.5000 rot=0
# pcb:sch ANT1 x=1611.9000 y=1199.1500 rot=0
# pcb:sch C_ANT1.C x=1362.9800 y=2196.1000 rot=0
# pcb:sch L_ANT1.L x=1303.9381 y=2145.3000 rot=270
# pcb:sch R_ANT.R x=1525.5400 y=1269.0000 rot=270
# pcb:sch L2.L x=1380.1381 y=2145.3000 rot=270
# pcb:sch C_ANT_PORT1.C x=1324.8800 y=1319.8000 rot=0
# pcb:sch C_ANT_PORT2.C x=1439.1800 y=1319.8000 rot=0
# pcb:sch L_ANT_MATCH.L x=1408.6991 y=1269.0000 rot=270
# pcb:sch J_JTAG.PH x=1637.3000 y=1891.3000 rot=0
# pcb:sch R_GPIO3.R x=649.2400 y=1459.5000 rot=90
# pcb:sch TP_RESET.TP x=1439.1800 y=1914.1600 rot=90
# pcb:sch C_VDD3P3_IN1.C x=1464.5800 y=1027.7000 rot=0
# pcb:sch C_VDD3P3_IN2.C x=524.7800 y=1230.9000 rot=0
# pcb:sch C_VDD3P3_IN3.C x=600.9800 y=1230.9000 rot=0
# pcb:sch C_VDD3P3_OUT.C x=702.5800 y=1230.9000 rot=0
# pcb:sch L_VDD3P3.L x=672.0991 y=1180.1000 rot=270
# pcb:sch VUSB.1 x=67.5800 y=1611.9000 rot=0
# pcb:sch VUSB.2 x=16.7800 y=1408.7000 rot=0