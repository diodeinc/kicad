"""PCA9548ADB - Low voltage 8-channel I2C switch with reset

The PCA9548A is an 8-channel, bidirectional translating I2C switch. The master SCL/SDA 
signal pair is directed to eight channels of slave devices, SC0/SD0-SC7/SD7. Any 
individual downstream channel or combination of channels can be selected. The device 
features 1-of-8 bidirectional translating switches, I2C bus and SMBus compatibility, 
active-low reset input, three hardware address pins for up to eight PCA9548A devices 
on the same I2C bus, and operates from 2.3V to 5.5V with 5V tolerant inputs.

This module supports configurable I2C pull-up resistor values for both upstream and 
downstream channels. Default values are 4.7kÎ© for both, suitable for Fast mode I2C.

Author: @anthropic/claude-opus-4
Reviewer: Nasheed Ur Rehman
Datasheet: https://www.ti.com/lit/ds/symlink/pca9548a.pdf
"""

load("@stdlib/interfaces.zen", "I2c", "Power", "Ground")

# Dependencies
Resistor = Module("@stdlib/generics/Resistor.zen")
Capacitor = Module("@stdlib/generics/Capacitor.zen")
TestPoint = Module("@stdlib/generics/TestPoint.zen")

# Types
AddressConfig = enum("0x70", "0x71", "0x72", "0x73", "0x74", "0x75", "0x76", "0x77")
ResetConfig = enum("None", "PullUp", "PullUpWithTestPoint")

# Configuration
add_bulk_cap = config("add_bulk_cap", bool, default = True)
add_decoupling = config("add_decoupling", bool, default = True)
add_upstream_pullups = config("add_upstream_pullups", bool, default = True)
add_downstream_pullups = config("add_downstream_pullups", bool, default = True)

# Pull-up resistor values - only used if pull-ups are enabled
if add_upstream_pullups:
    upstream_pullup_value = config("upstream_pullup_value", str, default = "4.7kohms", optional = True)
    
if add_downstream_pullups:
    downstream_pullup_value = config("downstream_pullup_value", str, default = "4.7kohms", optional = True)

# Address configuration
address = config("address", AddressConfig, default = "0x70")
expose_address_pins = config("expose_address_pins", bool, default = False)

# Reset configuration
reset_config = config("reset_config", ResetConfig, default = "PullUpWithTestPoint")

# Channel enable configuration
enabled_channels = config("enabled_channels", list, default = [0, 1, 2, 3, 4, 5, 6, 7])

# Test points
add_test_points = config("add_test_points", bool, default = True)

# External IO
VCC = io("VCC", Power)
GND = io("GND", Ground)

# I2C upstream interface
i2c_upstream = io("I2C_UPSTREAM", I2c)

# I2C downstream interfaces for enabled channels
i2c_downstream = []
for ch in enabled_channels:
    i2c_downstream.append(io(f"I2C_CH{ch}", I2c))

# All pullups use VCC
VDPU_MASTER = VCC
VDPU_CH = [VCC] * len(enabled_channels)

# Reset control - conditionally exposed based on reset configuration
if reset_config == ResetConfig("None"):
    RESET = io("RESET", Net)
    _RESET = RESET
else:
    _RESET = Net("RESET")

# Address pins - conditionally exposed
if expose_address_pins:
    A0 = io("A0", Net)
    A1 = io("A1", Net)
    A2 = io("A2", Net)
    _A0 = A0
    _A1 = A1
    _A2 = A2
else:
    # Internal nets for address pins
    _A0 = Net("A0")
    _A1 = Net("A1")
    _A2 = Net("A2")

# Create nets for all channels (some may not be exposed)
_SC = [Net(f"SC{i}") for i in range(8)]
_SD = [Net(f"SD{i}") for i in range(8)]

# Connect enabled channels to their interfaces
for idx, ch in enumerate(enabled_channels):
    _SC[ch] = i2c_downstream[idx].SCL
    _SD[ch] = i2c_downstream[idx].SDA

# Expose disabled channels as individual IOs
for ch in range(8):
    if ch not in enabled_channels:
        io(f"SC{ch}", Net, default = _SC[ch])
        io(f"SD{ch}", Net, default = _SD[ch])

# Address configuration
if not expose_address_pins:
    # Map address to pin states
    address_map = {
        AddressConfig("0x70"): (False, False, False),  # A2=L, A1=L, A0=L
        AddressConfig("0x71"): (False, False, True),   # A2=L, A1=L, A0=H
        AddressConfig("0x72"): (False, True, False),   # A2=L, A1=H, A0=L
        AddressConfig("0x73"): (False, True, True),    # A2=L, A1=H, A0=H
        AddressConfig("0x74"): (True, False, False),   # A2=H, A1=L, A0=L
        AddressConfig("0x75"): (True, False, True),    # A2=H, A1=L, A0=H
        AddressConfig("0x76"): (True, True, False),    # A2=H, A1=H, A0=L
        AddressConfig("0x77"): (True, True, True),     # A2=H, A1=H, A0=H
    }
    
    a2_high, a1_high, a0_high = address_map[address]
    
    # Connect address pins
    _A0 = VCC if a0_high else GND
    _A1 = VCC if a1_high else GND
    _A2 = VCC if a2_high else GND

# Main component
Component(
    name = "PCA9548ADB",
    symbol = Symbol(library = "@kicad-symbols/Interface_Expansion.kicad_sym", name = "PCA9548ADB"),
    footprint = File("@kicad-footprints/Package_SO.pretty/SSOP-24_5.3x8.2mm_P0.65mm.kicad_mod"),
    pins = {
        "A0": _A0,
        "A1": _A1,
        "~{RESET}": _RESET,
        "SD0": _SD[0],
        "SC0": _SC[0],
        "SD1": _SD[1],
        "SC1": _SC[1],
        "SD2": _SD[2],
        "SC2": _SC[2],
        "SD3": _SD[3],
        "SC3": _SC[3],
        "GND": GND,
        "SD4": _SD[4],
        "SC4": _SC[4],
        "SD5": _SD[5],
        "SC5": _SC[5],
        "SD6": _SD[6],
        "SC6": _SC[6],
        "SD7": _SD[7],
        "SC7": _SC[7],
        "A2": _A2,
        "SCL": i2c_upstream.SCL,
        "SDA": i2c_upstream.SDA,
        "VCC": VCC,
    },
)

# Power supply decoupling
if add_bulk_cap:
    Capacitor(name = "C_BULK", value = "10uF", package = "0805", P1 = VCC, P2 = GND)

if add_decoupling:
    Capacitor(name = "C_VCC", value = "100nF", package = "0402", P1 = VCC, P2 = GND)

# Reset circuit
if reset_config == ResetConfig("PullUp"):
    # Simple pull-up resistor
    Resistor(name = "R_RESET", value = "10kohms", package = "0402", P1 = _RESET, P2 = VCC)
    
elif reset_config == ResetConfig("PullUpWithTestPoint"):
    # Pull-up with test point for debug access
    Resistor(name = "R_RESET", value = "10kohms", package = "0402", P1 = _RESET, P2 = VCC)
    TestPoint(name = "TP_RESET", variant = "THTPad_D1.0mm_Drill0.5mm", P1 = _RESET)

# Upstream I2C pull-up resistors
if add_upstream_pullups:
    Resistor(name = "R_SCL_UP", value = upstream_pullup_value, package = "0402", 
             P1 = i2c_upstream.SCL, P2 = VDPU_MASTER)
    Resistor(name = "R_SDA_UP", value = upstream_pullup_value, package = "0402", 
             P1 = i2c_upstream.SDA, P2 = VDPU_MASTER)

# Downstream I2C pull-up resistors for enabled channels
if add_downstream_pullups:
    for idx, ch in enumerate(enabled_channels):
        Resistor(name = f"R_SCL_CH{ch}", value = downstream_pullup_value, package = "0402",
                 P1 = _SC[ch], P2 = VDPU_CH[idx])
        Resistor(name = f"R_SDA_CH{ch}", value = downstream_pullup_value, package = "0402",
                 P1 = _SD[ch], P2 = VDPU_CH[idx])

# Test points
if add_test_points:
    TestPoint(name = "TP_SCL_UP", variant = "THTPad_D1.0mm_Drill0.5mm", P1 = i2c_upstream.SCL)
    TestPoint(name = "TP_SDA_UP", variant = "THTPad_D1.0mm_Drill0.5mm", P1 = i2c_upstream.SDA)
    
    # Test points for enabled channels
    for ch in enabled_channels:
        TestPoint(name = f"TP_SCL_CH{ch}", variant = "THTPad_D1.0mm_Drill0.5mm", P1 = _SC[ch])
        TestPoint(name = f"TP_SDA_CH{ch}", variant = "THTPad_D1.0mm_Drill0.5mm", P1 = _SD[ch])

# pcb:sch C_BULK.C x=499.3800 y=265.7000 rot=0
# pcb:sch C_VCC.C x=613.6800 y=265.7000 rot=0
# pcb:sch PCA9548ADB x=913.4000 y=49.8000 rot=0
# pcb:sch R_RESET.R x=700.0400 y=11.7000 rot=180
# pcb:sch R_SCL_CH0.R x=1208.0400 y=392.7000 rot=180
# pcb:sch R_SCL_CH1.R x=1335.0400 y=392.7000 rot=180
# pcb:sch R_SCL_CH2.R x=1462.0400 y=392.7000 rot=180
# pcb:sch R_SCL_CH3.R x=1589.0400 y=392.7000 rot=180
# pcb:sch R_SCL_CH4.R x=1652.5400 y=75.2000 rot=180
# pcb:sch R_SCL_CH5.R x=1525.5400 y=75.2000 rot=180
# pcb:sch R_SCL_CH6.R x=1398.5400 y=75.2000 rot=180
# pcb:sch R_SCL_CH7.R x=1271.5400 y=75.2000 rot=180
# pcb:sch R_SCL_UP.R x=827.0400 y=11.7000 rot=180
# pcb:sch R_SDA_CH0.R x=1271.5400 y=392.7000 rot=180
# pcb:sch R_SDA_CH1.R x=1398.5400 y=392.7000 rot=180
# pcb:sch R_SDA_CH2.R x=1525.5400 y=392.7000 rot=180
# pcb:sch R_SDA_CH3.R x=1652.5400 y=392.7000 rot=180
# pcb:sch R_SDA_CH4.R x=1589.0400 y=75.2000 rot=180
# pcb:sch R_SDA_CH5.R x=1462.0400 y=75.2000 rot=180
# pcb:sch R_SDA_CH6.R x=1335.0400 y=75.2000 rot=180
# pcb:sch R_SDA_CH7.R x=1208.0400 y=75.2000 rot=180
# pcb:sch R_SDA_UP.R x=763.5400 y=11.7000 rot=180
# pcb:sch GND.1 x=1002.3000 y=570.5000 rot=0
# pcb:sch VCC.1 x=1007.3800 y=-51.8000 rot=0
# pcb:sch VCC.2 x=1210.5800 y=303.8000 rot=0
# pcb:sch VCC.3 x=1210.5800 y=-51.8000 rot=0

# pcb:sch TP_RESET.TP x=702.5800 y=199.6600 rot=180
# pcb:sch TP_SCL_CH0.TP x=1210.5800 y=466.3600 rot=180
# pcb:sch TP_SCL_CH1.TP x=1337.5800 y=466.3600 rot=180
# pcb:sch TP_SCL_CH2.TP x=1464.5800 y=466.3600 rot=180
# pcb:sch TP_SCL_CH3.TP x=1591.5800 y=466.3600 rot=180
# pcb:sch TP_SCL_CH4.TP x=1655.0800 y=148.8600 rot=180
# pcb:sch TP_SCL_CH5.TP x=1528.0800 y=148.8600 rot=180
# pcb:sch TP_SCL_CH6.TP x=1401.0800 y=148.8600 rot=180
# pcb:sch TP_SCL_CH7.TP x=1274.0800 y=148.8600 rot=180
# pcb:sch TP_SCL_UP.TP x=829.5800 y=110.7600 rot=180
# pcb:sch TP_SDA_CH0.TP x=1274.0800 y=466.3600 rot=180
# pcb:sch TP_SDA_CH1.TP x=1401.0800 y=466.3600 rot=180
# pcb:sch TP_SDA_CH2.TP x=1528.0800 y=466.3600 rot=180
# pcb:sch TP_SDA_CH3.TP x=1655.0800 y=466.3600 rot=180
# pcb:sch TP_SDA_CH4.TP x=1591.5800 y=148.8600 rot=180
# pcb:sch TP_SDA_CH5.TP x=1464.5800 y=148.8600 rot=180
# pcb:sch TP_SDA_CH6.TP x=1337.5800 y=148.8600 rot=180
# pcb:sch TP_SDA_CH7.TP x=1210.5800 y=148.8600 rot=180
# pcb:sch TP_SDA_UP.TP x=766.0800 y=110.7600 rot=180